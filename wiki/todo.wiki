#summary Things that need to be changed in the code.
#labels Deprecated

= Introduction =

Things that need to be changed in the code. Format: *Class.MethodName*: _Old Code Snippet_ -> _New Code Snippet_


= Details =
Add in support so that negative numbers can be parsed properly; have it so -? evaluates to 0 - ?.

*ScriptingLanguage.OperateBool*: Add in this before the other parsing.

_if (noOps[i].ToLower() == "true" || noOps[i].ToLower() == "false")
{
    vals.Add(i, new pBool(Parse.String2Bool(noOps[i])));
    continue;
}_

*ScriptingLanguage.OperateParam*:

New code for m_vars & m_interactvars
_
if (!toParse.ToLower().Contains(param.Key))
   continue;
int index = 0;
while ((index = toParse.ToLower().IndexOf(param.Key, index)) != -1)
_

*ScriptingLanguage.EvaluateBool*:

New code for first layer of parsing
_
bool isTrue = false;
ops[i] = ops[i].Trim();
if (ops[i] == m_opBool[2])
  isTrue = values[i] != values[i + 1];
else if (ops[i] == m_opBool[3])
  isTrue = values[i] != values[i + 1];
else if (ops[i] != m_opBool[0] && ops[i] != m_opBool[1])
  Error("Operator '" + ops[i] + "' not supported.");
else
  isTrue = (bool)values[i].Data;
vars.Add(isTrue);
if (i == ops.Count - 1 && (ops[i] == m_opBool[0] || ops[i] == m_opBool[1]))
  vars.Add((bool)values[i + 1].Data);
_

*ScriptingLanguage.EvaluateBool*:

_if (!vars[i] && vars[i + 1])_
_if (!(vars[i] && vars[i + 1]))_
By default, return false.